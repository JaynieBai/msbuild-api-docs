<Type Name="FlagsAndAttributes" FullName="Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes">
  <TypeSignature Language="C#" Value="public enum FlagsAndAttributes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed FlagsAndAttributes extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes" />
  <TypeSignature Language="VB.NET" Value="Public Enum FlagsAndAttributes" />
  <TypeSignature Language="F#" Value="type FlagsAndAttributes = " />
  <TypeSignature Language="C++ CLI" Value="public enum class FlagsAndAttributes" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Build</AssemblyName>
    <AssemblyVersion>15.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Flags]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Flags&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
            The file or device attributes and flags.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="FILE_ATTRIBUTE_ARCHIVE">
      <MemberSignature Language="C#" Value="FILE_ATTRIBUTE_ARCHIVE" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes FILE_ATTRIBUTE_ARCHIVE = unsigned int32(32)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_ATTRIBUTE_ARCHIVE" />
      <MemberSignature Language="VB.NET" Value="FILE_ATTRIBUTE_ARCHIVE" />
      <MemberSignature Language="F#" Value="FILE_ATTRIBUTE_ARCHIVE = 32" Usage="Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_ATTRIBUTE_ARCHIVE" />
      <MemberSignature Language="C++ CLI" Value="FILE_ATTRIBUTE_ARCHIVE" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes</ReturnType>
      </ReturnValue>
      <MemberValue>32</MemberValue>
      <Docs>
        <summary>
            The file should be archived. Applications use this attribute to mark files for backup or removal.
            </summary>
      </Docs>
    </Member>
    <Member MemberName="FILE_ATTRIBUTE_DIRECTORY">
      <MemberSignature Language="C#" Value="FILE_ATTRIBUTE_DIRECTORY" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes FILE_ATTRIBUTE_DIRECTORY = unsigned int32(16)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_ATTRIBUTE_DIRECTORY" />
      <MemberSignature Language="VB.NET" Value="FILE_ATTRIBUTE_DIRECTORY" />
      <MemberSignature Language="F#" Value="FILE_ATTRIBUTE_DIRECTORY = 16" Usage="Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_ATTRIBUTE_DIRECTORY" />
      <MemberSignature Language="C++ CLI" Value="FILE_ATTRIBUTE_DIRECTORY" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes</ReturnType>
      </ReturnValue>
      <MemberValue>16</MemberValue>
      <Docs>
        <summary>
            The path is a directory.
            </summary>
      </Docs>
    </Member>
    <Member MemberName="FILE_ATTRIBUTE_ENCRYPED">
      <MemberSignature Language="C#" Value="FILE_ATTRIBUTE_ENCRYPED" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes FILE_ATTRIBUTE_ENCRYPED = unsigned int32(16384)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_ATTRIBUTE_ENCRYPED" />
      <MemberSignature Language="VB.NET" Value="FILE_ATTRIBUTE_ENCRYPED" />
      <MemberSignature Language="F#" Value="FILE_ATTRIBUTE_ENCRYPED = 16384" Usage="Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_ATTRIBUTE_ENCRYPED" />
      <MemberSignature Language="C++ CLI" Value="FILE_ATTRIBUTE_ENCRYPED" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes</ReturnType>
      </ReturnValue>
      <MemberValue>16384</MemberValue>
      <Docs>
        <summary>
            The file or directory is encrypted. For a file, this means that all data in the file is encrypted. For a directory,
            this means that encryption is the default for newly created files and subdirectories. For more information, see File
            Encryption.
            </summary>
        <remarks>
            This flag has no effect if <see cref="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_ATTRIBUTE_SYSTEM" /> is also specified.
            This flag is not supported on Home, Home Premium, Starter, or ARM editions of Windows.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="FILE_ATTRIBUTE_HIDDEN">
      <MemberSignature Language="C#" Value="FILE_ATTRIBUTE_HIDDEN" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes FILE_ATTRIBUTE_HIDDEN = unsigned int32(2)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_ATTRIBUTE_HIDDEN" />
      <MemberSignature Language="VB.NET" Value="FILE_ATTRIBUTE_HIDDEN" />
      <MemberSignature Language="F#" Value="FILE_ATTRIBUTE_HIDDEN = 2" Usage="Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_ATTRIBUTE_HIDDEN" />
      <MemberSignature Language="C++ CLI" Value="FILE_ATTRIBUTE_HIDDEN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>
            The file is hidden. Do not include it in an ordinary directory listing.
            </summary>
      </Docs>
    </Member>
    <Member MemberName="FILE_ATTRIBUTE_NORMAL">
      <MemberSignature Language="C#" Value="FILE_ATTRIBUTE_NORMAL" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes FILE_ATTRIBUTE_NORMAL = unsigned int32(128)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_ATTRIBUTE_NORMAL" />
      <MemberSignature Language="VB.NET" Value="FILE_ATTRIBUTE_NORMAL" />
      <MemberSignature Language="F#" Value="FILE_ATTRIBUTE_NORMAL = 128" Usage="Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_ATTRIBUTE_NORMAL" />
      <MemberSignature Language="C++ CLI" Value="FILE_ATTRIBUTE_NORMAL" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes</ReturnType>
      </ReturnValue>
      <MemberValue>128</MemberValue>
      <Docs>
        <summary>
            The file does not have other attributes set. This attribute is valid only if used alone.
            </summary>
      </Docs>
    </Member>
    <Member MemberName="FILE_ATTRIBUTE_OFFLINE">
      <MemberSignature Language="C#" Value="FILE_ATTRIBUTE_OFFLINE" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes FILE_ATTRIBUTE_OFFLINE = unsigned int32(4096)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_ATTRIBUTE_OFFLINE" />
      <MemberSignature Language="VB.NET" Value="FILE_ATTRIBUTE_OFFLINE" />
      <MemberSignature Language="F#" Value="FILE_ATTRIBUTE_OFFLINE = 4096" Usage="Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_ATTRIBUTE_OFFLINE" />
      <MemberSignature Language="C++ CLI" Value="FILE_ATTRIBUTE_OFFLINE" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes</ReturnType>
      </ReturnValue>
      <MemberValue>4096</MemberValue>
      <Docs>
        <summary>
            The data of a file is not immediately available. This attribute indicates that file data is physically moved to offline
            storage. This attribute is used by Remote Storage, the hierarchical storage management software. Applications should
            not arbitrarily change this attribute.
            </summary>
      </Docs>
    </Member>
    <Member MemberName="FILE_ATTRIBUTE_READONLY">
      <MemberSignature Language="C#" Value="FILE_ATTRIBUTE_READONLY" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes FILE_ATTRIBUTE_READONLY = unsigned int32(1)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_ATTRIBUTE_READONLY" />
      <MemberSignature Language="VB.NET" Value="FILE_ATTRIBUTE_READONLY" />
      <MemberSignature Language="F#" Value="FILE_ATTRIBUTE_READONLY = 1" Usage="Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_ATTRIBUTE_READONLY" />
      <MemberSignature Language="C++ CLI" Value="FILE_ATTRIBUTE_READONLY" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>
            The file is read only. Applications can read the file but cannot write to or delete it.
            </summary>
      </Docs>
    </Member>
    <Member MemberName="FILE_ATTRIBUTE_SYSTEM">
      <MemberSignature Language="C#" Value="FILE_ATTRIBUTE_SYSTEM" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes FILE_ATTRIBUTE_SYSTEM = unsigned int32(4)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_ATTRIBUTE_SYSTEM" />
      <MemberSignature Language="VB.NET" Value="FILE_ATTRIBUTE_SYSTEM" />
      <MemberSignature Language="F#" Value="FILE_ATTRIBUTE_SYSTEM = 4" Usage="Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_ATTRIBUTE_SYSTEM" />
      <MemberSignature Language="C++ CLI" Value="FILE_ATTRIBUTE_SYSTEM" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes</ReturnType>
      </ReturnValue>
      <MemberValue>4</MemberValue>
      <Docs>
        <summary>
            The file is part of or used exclusively by an operating system.
            </summary>
      </Docs>
    </Member>
    <Member MemberName="FILE_ATTRIBUTE_TEMPORARY">
      <MemberSignature Language="C#" Value="FILE_ATTRIBUTE_TEMPORARY" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes FILE_ATTRIBUTE_TEMPORARY = unsigned int32(256)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_ATTRIBUTE_TEMPORARY" />
      <MemberSignature Language="VB.NET" Value="FILE_ATTRIBUTE_TEMPORARY" />
      <MemberSignature Language="F#" Value="FILE_ATTRIBUTE_TEMPORARY = 256" Usage="Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_ATTRIBUTE_TEMPORARY" />
      <MemberSignature Language="C++ CLI" Value="FILE_ATTRIBUTE_TEMPORARY" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes</ReturnType>
      </ReturnValue>
      <MemberValue>256</MemberValue>
      <Docs>
        <summary>
            The file is being used for temporary storage.
            </summary>
        <remarks>
            For more information, see the Caching Behavior section of this topic.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="FILE_FLAG_BACKUP_SEMANTICS">
      <MemberSignature Language="C#" Value="FILE_FLAG_BACKUP_SEMANTICS" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes FILE_FLAG_BACKUP_SEMANTICS = unsigned int32(33554432)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_BACKUP_SEMANTICS" />
      <MemberSignature Language="VB.NET" Value="FILE_FLAG_BACKUP_SEMANTICS" />
      <MemberSignature Language="F#" Value="FILE_FLAG_BACKUP_SEMANTICS = 33554432" Usage="Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_BACKUP_SEMANTICS" />
      <MemberSignature Language="C++ CLI" Value="FILE_FLAG_BACKUP_SEMANTICS" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes</ReturnType>
      </ReturnValue>
      <MemberValue>33554432</MemberValue>
      <Docs>
        <summary>
            The file is being opened or created for a backup or restore operation. The system ensures that the calling process
            overrides file security checks when the process has SE_BACKUP_NAME and SE_RESTORE_NAME privileges. For more
            information, see Changing Privileges in a Token.
            </summary>
        <remarks>
            You must set this flag to obtain a handle to a directory. A directory handle can be passed to some functions instead of
            a file handle. For more information, see the Remarks section.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="FILE_FLAG_DELETE_ON_CLOSE">
      <MemberSignature Language="C#" Value="FILE_FLAG_DELETE_ON_CLOSE" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes FILE_FLAG_DELETE_ON_CLOSE = unsigned int32(67108864)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_DELETE_ON_CLOSE" />
      <MemberSignature Language="VB.NET" Value="FILE_FLAG_DELETE_ON_CLOSE" />
      <MemberSignature Language="F#" Value="FILE_FLAG_DELETE_ON_CLOSE = 67108864" Usage="Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_DELETE_ON_CLOSE" />
      <MemberSignature Language="C++ CLI" Value="FILE_FLAG_DELETE_ON_CLOSE" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes</ReturnType>
      </ReturnValue>
      <MemberValue>67108864</MemberValue>
      <Docs>
        <summary>
            The file is to be deleted immediately after all of its handles are closed, which includes the specified handle and any
            other open or duplicated handles.
            </summary>
        <remarks>
            If there are existing open handles to a file, the call fails unless they were all opened with the FILE_SHARE_DELETE
            share mode.
            Subsequent open requests for the file fail, unless the FILE_SHARE_DELETE share mode is specified.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="FILE_FLAG_NO_BUFFERING">
      <MemberSignature Language="C#" Value="FILE_FLAG_NO_BUFFERING" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes FILE_FLAG_NO_BUFFERING = unsigned int32(536870912)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_NO_BUFFERING" />
      <MemberSignature Language="VB.NET" Value="FILE_FLAG_NO_BUFFERING" />
      <MemberSignature Language="F#" Value="FILE_FLAG_NO_BUFFERING = 536870912" Usage="Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_NO_BUFFERING" />
      <MemberSignature Language="C++ CLI" Value="FILE_FLAG_NO_BUFFERING" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes</ReturnType>
      </ReturnValue>
      <MemberValue>536870912</MemberValue>
      <Docs>
        <summary>
            The file or device is being opened with no system caching for data reads and writes. This flag does not affect hard
            disk caching or memory mapped files.
            </summary>
        <remarks>
            There are strict requirements for successfully working with files opened with CreateFile using this
            flag; for details, see File Buffering.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="FILE_FLAG_OPEN_NO_RECALL">
      <MemberSignature Language="C#" Value="FILE_FLAG_OPEN_NO_RECALL" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes FILE_FLAG_OPEN_NO_RECALL = unsigned int32(1048576)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_OPEN_NO_RECALL" />
      <MemberSignature Language="VB.NET" Value="FILE_FLAG_OPEN_NO_RECALL" />
      <MemberSignature Language="F#" Value="FILE_FLAG_OPEN_NO_RECALL = 1048576" Usage="Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_OPEN_NO_RECALL" />
      <MemberSignature Language="C++ CLI" Value="FILE_FLAG_OPEN_NO_RECALL" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes</ReturnType>
      </ReturnValue>
      <MemberValue>1048576</MemberValue>
      <Docs>
        <summary>
            The file data is requested, but it should continue to be located in remote storage. It should not be transported back
            to local storage. This flag is for use by remote storage systems.
            </summary>
      </Docs>
    </Member>
    <Member MemberName="FILE_FLAG_OPEN_REPARSE_POINT">
      <MemberSignature Language="C#" Value="FILE_FLAG_OPEN_REPARSE_POINT" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes FILE_FLAG_OPEN_REPARSE_POINT = unsigned int32(2097152)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_OPEN_REPARSE_POINT" />
      <MemberSignature Language="VB.NET" Value="FILE_FLAG_OPEN_REPARSE_POINT" />
      <MemberSignature Language="F#" Value="FILE_FLAG_OPEN_REPARSE_POINT = 2097152" Usage="Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_OPEN_REPARSE_POINT" />
      <MemberSignature Language="C++ CLI" Value="FILE_FLAG_OPEN_REPARSE_POINT" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes</ReturnType>
      </ReturnValue>
      <MemberValue>2097152</MemberValue>
      <Docs>
        <summary>
            Normal reparse point processing will not occur; CreateFile will attempt to open the reparse point. When a file is
            opened, a file handle is returned, whether or not the filter that controls the reparse point is operational.
            </summary>
        <remarks>
            This flag cannot be used with the CREATE_ALWAYS flag.
            If the file is not a reparse point, then this flag is ignored.
            For more information, see the Remarks section.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="FILE_FLAG_OVERLAPPED">
      <MemberSignature Language="C#" Value="FILE_FLAG_OVERLAPPED" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes FILE_FLAG_OVERLAPPED = unsigned int32(1073741824)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_OVERLAPPED" />
      <MemberSignature Language="VB.NET" Value="FILE_FLAG_OVERLAPPED" />
      <MemberSignature Language="F#" Value="FILE_FLAG_OVERLAPPED = 1073741824" Usage="Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_OVERLAPPED" />
      <MemberSignature Language="C++ CLI" Value="FILE_FLAG_OVERLAPPED" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes</ReturnType>
      </ReturnValue>
      <MemberValue>1073741824</MemberValue>
      <Docs>
        <summary>
            The file or device is being opened or created for asynchronous I/O.
            </summary>
        <remarks>
            When subsequent I/O operations are completed on this handle, the event specified in the OVERLAPPED structure will be
            set to the signaled state.
            If this flag is specified, the file can be used for simultaneous read and write operations.
            If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write functions
            specify an OVERLAPPED structure.
            For information about considerations when using a file handle created with this flag, see the Synchronous and
            Asynchronous I/O Handles section of this topic.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="FILE_FLAG_POSIX_SEMANTICS">
      <MemberSignature Language="C#" Value="FILE_FLAG_POSIX_SEMANTICS" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes FILE_FLAG_POSIX_SEMANTICS = unsigned int32(16777216)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_POSIX_SEMANTICS" />
      <MemberSignature Language="VB.NET" Value="FILE_FLAG_POSIX_SEMANTICS" />
      <MemberSignature Language="F#" Value="FILE_FLAG_POSIX_SEMANTICS = 16777216" Usage="Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_POSIX_SEMANTICS" />
      <MemberSignature Language="C++ CLI" Value="FILE_FLAG_POSIX_SEMANTICS" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes</ReturnType>
      </ReturnValue>
      <MemberValue>16777216</MemberValue>
      <Docs>
        <summary>
            Access will occur according to POSIX rules. This includes allowing multiple files with names, differing only in case,
            for file systems that support that naming. Use care when using this option, because files created with this flag may
            not be accessible by applications that are written for MS-DOS or 16-bit Windows.
            </summary>
      </Docs>
    </Member>
    <Member MemberName="FILE_FLAG_RANDOM_ACCESS">
      <MemberSignature Language="C#" Value="FILE_FLAG_RANDOM_ACCESS" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes FILE_FLAG_RANDOM_ACCESS = unsigned int32(268435456)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_RANDOM_ACCESS" />
      <MemberSignature Language="VB.NET" Value="FILE_FLAG_RANDOM_ACCESS" />
      <MemberSignature Language="F#" Value="FILE_FLAG_RANDOM_ACCESS = 268435456" Usage="Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_RANDOM_ACCESS" />
      <MemberSignature Language="C++ CLI" Value="FILE_FLAG_RANDOM_ACCESS" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes</ReturnType>
      </ReturnValue>
      <MemberValue>268435456</MemberValue>
      <Docs>
        <summary>
            Access is intended to be random. The system can use this as a hint to optimize file caching.
            </summary>
        <remarks>
            This flag has no effect if the file system does not support cached I/O and <see cref="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_NO_BUFFERING" />.
            For more information, see the Caching Behavior section of this topic.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="FILE_FLAG_SEQUENTIAL_SCAN">
      <MemberSignature Language="C#" Value="FILE_FLAG_SEQUENTIAL_SCAN" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes FILE_FLAG_SEQUENTIAL_SCAN = unsigned int32(134217728)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_SEQUENTIAL_SCAN" />
      <MemberSignature Language="VB.NET" Value="FILE_FLAG_SEQUENTIAL_SCAN" />
      <MemberSignature Language="F#" Value="FILE_FLAG_SEQUENTIAL_SCAN = 134217728" Usage="Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_SEQUENTIAL_SCAN" />
      <MemberSignature Language="C++ CLI" Value="FILE_FLAG_SEQUENTIAL_SCAN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes</ReturnType>
      </ReturnValue>
      <MemberValue>134217728</MemberValue>
      <Docs>
        <summary>
            Access is intended to be sequential from beginning to end. The system can use this as a hint to optimize file caching.
            </summary>
        <remarks>
            This flag should not be used if read-behind (that is, reverse scans) will be used.
            This flag has no effect if the file system does not support cached I/O and <see cref="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_NO_BUFFERING" /> .
            For more information, see the Caching Behavior section of this topic.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="FILE_FLAG_SESSION_AWARE">
      <MemberSignature Language="C#" Value="FILE_FLAG_SESSION_AWARE" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes FILE_FLAG_SESSION_AWARE = unsigned int32(8388608)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_SESSION_AWARE" />
      <MemberSignature Language="VB.NET" Value="FILE_FLAG_SESSION_AWARE" />
      <MemberSignature Language="F#" Value="FILE_FLAG_SESSION_AWARE = 8388608" Usage="Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_SESSION_AWARE" />
      <MemberSignature Language="C++ CLI" Value="FILE_FLAG_SESSION_AWARE" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes</ReturnType>
      </ReturnValue>
      <MemberValue>8388608</MemberValue>
      <Docs>
        <summary>
            The file or device is being opened with session awareness. If this flag is not specified, then per-session devices
            (such as a redirected USB device) cannot be opened by processes running in session 0. This flag has no effect for
            callers not in session 0. This flag is supported only on server editions of Windows.
            </summary>
        <remarks>
            Windows Server 2008 R2, Windows Server 2008, and Windows Server 2003: This flag is not supported before Windows Server
            2012.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="FILE_FLAG_WRITE_THROUGH">
      <MemberSignature Language="C#" Value="FILE_FLAG_WRITE_THROUGH" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes FILE_FLAG_WRITE_THROUGH = unsigned int32(2147483648)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_WRITE_THROUGH" />
      <MemberSignature Language="VB.NET" Value="FILE_FLAG_WRITE_THROUGH" />
      <MemberSignature Language="F#" Value="FILE_FLAG_WRITE_THROUGH = 2147483648" Usage="Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes.FILE_FLAG_WRITE_THROUGH" />
      <MemberSignature Language="C++ CLI" Value="FILE_FLAG_WRITE_THROUGH" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes</ReturnType>
      </ReturnValue>
      <MemberValue>2147483648</MemberValue>
      <Docs>
        <summary>
            Write operations will not go through any intermediate cache; they will go directly to disk.
            </summary>
        <remarks>
            For additional information, see the Caching Behavior section of this topic.
            </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
